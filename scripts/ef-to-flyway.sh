#!/bin/bash

# EF Core to Flyway Migration Converter
# Converts Entity Framework migrations to Flyway-compatible SQL files

set -e  # Exit on any error

# Default values
STARTUP_PROJECT="./backend/Upstart/Upstart.Api/Upstart.Api.csproj"
PROJECT_PATH="./backend/Upstart/Upstart.Persistence/Upstart.Persistence.csproj"
OUTPUT_PATH="./flyway/upstart/migrations"
DB_CONTEXT="Upstart.Persistence.Data.UpstartDbContext"
MIGRATION_NAME=""

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Function to display usage
usage() {
    echo "Usage: $0 -n <migration_name> [-s startup_project] [-p project_path] [-o output_path]"
    echo ""
    echo "Options:"
    echo "  -n, --name           Migration name (required)"
    echo "  -s, --startup        Startup project path (default: $STARTUP_PROJECT)"
    echo "  -p, --project        Project containing DbContext (default: $PROJECT_PATH)"
    echo "  -o, --output         Output path for Flyway migrations (default: $OUTPUT_PATH)"
    echo "  -h, --help           Show this help message"
    echo ""
    echo "Examples:"
    echo "  $0 -n \"InitialCreate\""
    echo "  $0 -n \"AddIndexes\" -s \"../backend/Upstart.Api\""
    exit 1
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -n|--name)
            MIGRATION_NAME="$2"
            shift 2
            ;;
        -s|--startup)
            STARTUP_PROJECT="$2"
            shift 2
            ;;
        -p|--project)
            PROJECT_PATH="$2"
            shift 2
            ;;
        -o|--output)
            OUTPUT_PATH="$2"
            shift 2
            ;;
        -h|--help)
            usage
            ;;
        *)
            echo "Unknown option: $1"
            usage
            ;;
    esac
done

# Validate required parameters
if [[ -z "$MIGRATION_NAME" ]]; then
    echo -e "${RED}Error: Migration name is required${NC}"
    usage
fi

# Function to get next migration version number
get_next_migration_version() {
    local migrations_path="$1"
    
    if [[ ! -d "$migrations_path" ]]; then
        mkdir -p "$migrations_path"
        echo "V1"
        return
    fi
    
    # Find the highest version number
    local max_version=0
    for file in "$migrations_path"/V*.sql; do
        if [[ -f "$file" ]]; then
            local basename=$(basename "$file")
            if [[ $basename =~ ^V([0-9]+) ]]; then
                local version=${BASH_REMATCH[1]}
                if [[ $version -gt $max_version ]]; then
                    max_version=$version
                fi
            fi
        fi
    done
    
    echo "V$((max_version + 1))"
}

# Function to clean SQL content
clean_sql_content() {
    local content="$1"
    
    # Remove all EF-specific idempotency checks and migration history references
    echo "$content" | \
        sed '/^Build started\.\.\./d' | \
        sed '/^Build succeeded\./d' | \
        sed '/^warn:/d' | \
        sed '/^info:/d' | \
        sed '/-- <auto-generated/,/\/>/d' | \
        sed 's/\/\*.*\*\///g' | \
        sed '/CREATE TABLE.*__EFMigrationsHistory/,/);/d' | \
        sed '/CREATE TABLE IF NOT EXISTS.*__EFMigrationsHistory/,/);/d' | \
        sed '/INSERT INTO.*__EFMigrationsHistory/d' | \
        sed '/IF NOT EXISTS.*__EFMigrationsHistory/d' | \
        sed '/DO \$EF\$/,/\$EF\$/d' | \
        sed '/START TRANSACTION;/d' | \
        sed '/COMMIT;/d' | \
        sed '/^[[:space:]]*$/d' | \
        sed 's/^[[:space:]]*//' | \
        sed 's/[[:space:]]*$//' | \
        grep -v '^[[:space:]]*$'
}

# Function to check if dotnet-ef is installed
check_dotnet_ef() {
    if ! dotnet tool list --global | grep -q "dotnet-ef"; then
        echo -e "${YELLOW}‚ö†Ô∏è  Installing dotnet-ef tool...${NC}"
        dotnet tool install --global dotnet-ef
        if [[ $? -ne 0 ]]; then
            echo -e "${RED}‚ùå Failed to install dotnet-ef tool${NC}"
            exit 1
        fi
    fi
}

# Main execution
echo -e "${GREEN}üöÄ Starting EF to Flyway migration conversion...${NC}"
echo -e "${YELLOW}Migration Name: $MIGRATION_NAME${NC}"

# Check prerequisites
check_dotnet_ef

# Create temporary directory
TEMP_DIR=$(mktemp -d)
trap "rm -rf $TEMP_DIR" EXIT

echo -e "${BLUE}üìù Generating EF Core migration...${NC}"

#/usr/local/share/dotnet/dotnet ef migrations add \
# --project Upstart.Persistence/Upstart.Persistence.csproj \
# --startup-project Upstart.Api/Upstart.Api.csproj \
# --context Upstart.Persistence.Data.UpstartDbContext \
# --configuration Debug Initial \
# --output-dir Migrations

# Generate EF migration (in the normal Migrations folder, not temp dir)
if ! dotnet ef migrations add "$MIGRATION_NAME" \
    --project "$PROJECT_PATH" \
    --startup-project "$STARTUP_PROJECT" \
    --context "$DB_CONTEXT" 2>/dev/null; then
    echo -e "${RED}‚ùå EF migration generation failed${NC}"
    exit 1
fi

echo -e "${GREEN}‚úÖ EF migration generated successfully${NC}"

# Generate SQL script from migration
echo -e "${BLUE}üîÑ Generating SQL script...${NC}"

# Create a temporary file to capture both stdout and stderr
TEMP_SQL_FILE=$(mktemp)
TEMP_ERROR_FILE=$(mktemp)

# Try to generate SQL script with better error handling  
if dotnet ef migrations script \
    --project "$PROJECT_PATH" \
    --startup-project "$STARTUP_PROJECT" \
    --context "$DB_CONTEXT" > "$TEMP_SQL_FILE" 2> "$TEMP_ERROR_FILE"; then
    
    SQL_SCRIPT=$(cat "$TEMP_SQL_FILE")
    
    # Check if we actually got SQL content
    if [[ -z "$SQL_SCRIPT" || "$SQL_SCRIPT" =~ ^[[:space:]]*$ ]]; then
        echo -e "${RED}‚ùå SQL script generation produced no output${NC}"
        echo -e "${YELLOW}Error output:${NC}"
        cat "$TEMP_ERROR_FILE"
        echo -e "${YELLOW}Raw output:${NC}"
        cat "$TEMP_SQL_FILE"
        echo -e "${YELLOW}Debugging: Let's try a different approach...${NC}"
        
        # Try without idempotent flag
        echo -e "${BLUE}Trying without --idempotent flag...${NC}"
        if dotnet ef migrations script \
            --project "$PROJECT_PATH" \
            --startup-project "$STARTUP_PROJECT" \
            --context "$DB_CONTEXT" > "$TEMP_SQL_FILE" 2> "$TEMP_ERROR_FILE"; then
            SQL_SCRIPT=$(cat "$TEMP_SQL_FILE")
            echo -e "${YELLOW}Output with no --idempotent:${NC}"
            echo "$SQL_SCRIPT"
        else
            echo -e "${RED}That failed too. Error:${NC}"
            cat "$TEMP_ERROR_FILE"
        fi
        
        exit 1
    fi
else
    echo -e "${RED}‚ùå SQL script generation failed${NC}"
    echo -e "${YELLOW}Error output:${NC}"
    cat "$TEMP_ERROR_FILE"
    exit 1
fi

# Clean up temp files
rm -f "$TEMP_SQL_FILE" "$TEMP_ERROR_FILE"

# Get next version number
VERSION=$(get_next_migration_version "$OUTPUT_PATH")

# Clean and format SQL content
CLEAN_SQL=$(clean_sql_content "$SQL_SCRIPT")

# Create Flyway migration file
FLYWAY_FILENAME="${VERSION}__${MIGRATION_NAME}.sql"
FLYWAY_FILEPATH="$OUTPUT_PATH/$FLYWAY_FILENAME"

# Ensure output directory exists
mkdir -p "$OUTPUT_PATH"

# Create Flyway migration file with header
cat > "$FLYWAY_FILEPATH" << EOF
-- Flyway migration: $MIGRATION_NAME
-- Generated from EF Core migration on $(date '+%Y-%m-%d %H:%M:%S')
-- Description: $MIGRATION_NAME

$CLEAN_SQL
EOF

echo -e "${GREEN}‚úÖ Flyway migration created: $FLYWAY_FILENAME${NC}"
echo -e "${CYAN}üìÅ Location: $FLYWAY_FILEPATH${NC}"

# Ask if user wants to remove EF migration files
echo -n -e "${YELLOW}üóëÔ∏è  Remove EF migration files? (y/N): ${NC}"
read -r remove_ef_files

if [[ "$remove_ef_files" =~ ^[Yy]$ ]]; then
    if dotnet ef migrations remove \
        --project "$PROJECT_PATH" \
        --startup-project "$STARTUP_PROJECT" \
        --force 2>/dev/null; then
        echo -e "${YELLOW}üóëÔ∏è  EF migration files removed${NC}"
    else
        echo -e "${RED}‚ö†Ô∏è  Failed to remove EF migration files${NC}"
    fi
fi

echo -e "\n${GREEN}üéâ Migration conversion completed successfully!${NC}"
echo -e "${YELLOW}Next steps:${NC}"
echo -e "${NC}1. Review the generated SQL file: $FLYWAY_FILENAME${NC}"
echo -e "${NC}2. Run flyway migrate to apply the migration${NC}"
echo -e "${NC}3. Test the migration in your development environment${NC}"

echo -e "\n${CYAN}To run the migration with Flyway:${NC}"
echo -e "${NC}  cd flyway/upstart${NC}"
echo -e "${NC}  flyway migrate${NC}"